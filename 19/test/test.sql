drop schema pg cascade;
create schema pg;

create table pg.customer(id integer GENERATED BY DEFAULT AS IDENTITY, name varchar(100), city varchar(58), status varchar(8), primary key (id));
create table pg.order(id integer primary key generated by default as identity, customer_id integer, value decimal(10, 2), date date, status varchar(9), constraint fk_customerId_orderId foreign key(customer_id) references pg.customer(id));

CREATE OR REPLACE FUNCTION pg.charge() RETURNS VOID AS $$
DECLARE
    names TEXT[] := ARRAY['Abdul Hartman', 'Patti Wong', 'Jayson Lawson', 'Gina Moreno', 'Mose Dunlap', 'Hilary Holland', 'Lucile Saunders', 'Mildred Charles', 'Derick Mccoy', 'Grady Mosle'];
    cities TEXT[] := ARRAY['Casablanca', 'Sofia', 'Brisbane', 'Madrid', 'Seoul'];
    customer_statuses TEXT[] := ARRAY['active', 'inactive'];
    random_customer_name VARCHAR(15);
    random_customer_city VARCHAR(10);
    random_customer_status VARCHAR(8);

    i INTEGER;
    customer_ids INTEGER[] := ARRAY[]::integer[];
    order_statuses TEXT[] := ARRAY['pending', 'shipped', 'completed'];
    random_customer_id INTEGER;
    random_order_value DECIMAL(10, 2);
    random_order_date DATE;
    random_order_status VARCHAR(9);
BEGIN
    FOREACH random_customer_name IN ARRAY names LOOP
        -- trunc removes the floating point.
        -- random generates a number between 0 and 1.
        -- array_upper returns the array size.
        -- In plpgsql, the first element in the array is in position 1, not 0 (thus the +1).
        -- So the logic is: generate a number between 0 and 1, then multiply it by the number of elements in the array. Then, take its integer part. Add 1 to it. The result is a valid position in the array.
        random_customer_city := (SELECT cities[TRUNC(RANDOM() * ARRAY_UPPER(cities, 1)) + 1]);
        random_customer_status := (SELECT customer_statuses[TRUNC(RANDOM() * ARRAY_UPPER(customer_statuses, 1)) + 1]);

        INSERT INTO pg.customer (name, city, status)
        VALUES (random_customer_name, random_customer_city, random_customer_status);
    END LOOP;

    customer_ids := ARRAY(SELECT id FROM pg.customer);

    FOR i IN 1..1000 LOOP
        random_customer_id := (SELECT customer_ids[TRUNC(RANDOM() * ARRAY_UPPER(customer_ids, 1)) + 1]);
        random_order_value := (SELECT RANDOM() * 10000);
        random_order_date := (SELECT (CURRENT_DATE - INTERVAL '1 month' * TRUNC(RANDOM() * 11 + 1))::date);
        random_order_status := (SELECT order_statuses[TRUNC(RANDOM() * ARRAY_UPPER(order_statuses, 1)) + 1]);

        INSERT INTO pg.order (customer_id, value, date, status)
        VALUES (random_customer_id, random_order_value, random_order_date, random_order_status);
    END LOOP;
END;
$$ LANGUAGE PLPGSQL;


SELECT pg.charge();

-- 1
create view pg.active_customers as (select * from pg.customer where status = 'active');

-- 2
drop view pg.active_customers;
create view pg.active_customers as (select * from pg.customer where city in ('SÃ£o Paulo', 'Rio de Janeiro'));

-- 3
create view pg.customers_summary as (select id, name, city from pg.customer);

-- 4
create view pg.orders_with_tax as (select id, customer_id, value + value * 10/100 as total_value, date from pg.order);

-- 5
create view pg.customer_orders_summary as (select id, name, city, total from pg.customer join (select sum(value) as total, customer_id from pg.order group by customer_id) o on customer.id = o.customer_id);

-- 6
create view pg.recent_orders as (select * from pg.order where date >= now()::date - 30);

-- 7
-- Even though it is possible, there are restriction when updating a view in PostgreSQL. For instance, if the view uses any aggregation function, then it will not be possible to update the original table using the view. That is the same case when the view only uses raw values, like fixed numbers, for example.
-- In this case specifically, if the available_stock view only filters data from the stock table, and only returns columns from this same table, without any extra logic, there is absolutely no problem to perform an update. If that is not the case, when an error will be thrown when executing the operation.

-- 8
create view pg.v as (select 1 from pg.customer);
drop view pg.v;
select 1 from pg.customer;

-- 9
select rank() over (order by total desc), customer_id, total from (select customer_id, sum(value) as total from pg.order group by customer_id);

-- 10
create materialized view pg.orders_analysis as (select date_part('year', date) as year, date_part('month', date) as month, count(id) from pg.order group by date_part('year', date), date_part('month', date));
select pg.charge();
refresh materialized view pg.orders_analysis;

-- 11
drop view if exists pg.top_customers;
create view pg.top_customers as (select pg.customer.name, iq.customer_id, iq.amnt from pg.customer join (select customer_id, sum(value) as amnt from pg.order group by customer_id order by sum(value) desc limit 5) as iq on iq.customer_id = pg.customer.id);

-- 12
drop view if exists pg.orders_by_status;
create view pg.orders_by_status as (select * from pg.order where status in ((select status from pg.order group by (status) having count(*) > 10)));

-- 13
drop view if exists pg.sales_summary;
create view pg.sales_summary as (
select pg.customer.id, pg.customer.name, total_sales_per_costumer.total_sales_value from pg.customer 	join (select customer_id, sum(value) as total_sales_value from pg.order group by customer_id) as total_sales_per_costumer on pg.customer.id = total_sales_per_costumer.customer_id
);

-- 14
drop view if exists pg.orders_status;
create view pg.orders_status as (
select id, status, date, case when date < current_date::date and status = 'pending' then 'delayed' else 'nah' end as delayed_status from pg.order
);

-- 15
drop table if exists daily_sales_totals cascade;
select sum(value) as total_sales_per_day, date into temporary table daily_sales_totals from pg.order group by date;
drop view if exists total_sales_per_month; -- It is possible to use a temporary table in a view. But the view will also be temporary.
create view total_sales_per_month as (select sum(total_sales_per_day), date_part('month', date) as month, date_part('year', date) as year from daily_sales_totals group by date_part('month', date), date_part('year', date));